from os import remove
import numpy as np
from block import BlkID, Block
from globalVariables import *

rho_ij = 0.01 + (0.5 - 0.01)*rng.random() # Value of speed of light propagation delay, chosen at beginning of simulation
TXNID = 0 # Incremented every time a txn is generated

# Broadcast txn to neighbors of a peer
def broadcastTxnToNeighbors(time, peerID, txn):
    peer = nodeList[peerID] # peer who is sending the txn
    for p in peer.neighbors:
        neighbor = nodeList[p]

        # latency generated as described in problem statement, |m| = 1 KB = 8*1024 bits as size of txn is fixed
        c_ij = 100
        d_ij = rng.exponential(96/(1024*c_ij))
        latency = rho_ij + 8/(1024*c_ij) + d_ij

        recTime = time + latency 
        pq.put((recTime, next(unique), ReceiveTransaction(recTime, neighbor.id, txn)))

# Broadcast block to neighbors of a peer
def broadcastBlockToNeighbors(time, peerID, block):
    peer = nodeList[peerID] # peer who is sending the block
    for p in peer.neighbors:
        neighbor = nodeList[p]

        # latency generated as described in problem statement, |m| = numTxns * 1KB = numTxns*8*1024 bits as size of txn is fixed
        c_ij = 100
        d_ij = rng.exponential(96/(1024*c_ij))
        latency = rho_ij + 8*len(block.txns)/(1024*c_ij) + d_ij

        recTime = time + latency
        pq.put((recTime, next(unique), ReceiveBlock(recTime, neighbor.id, block, peer.id)))

# Event for generating a Txn
class GenerateTransaction():
    # Txn for 'peer1ID' pays 'peer2ID' 'amount' coins
    def __init__(self, time, peer1ID, peer2ID, amount):
        self.time = time
        self.peer1ID = peer1ID
        self.peer2ID = peer2ID
        self.amount = amount
    
    def process(self):
        peer1 = nodeList[self.peer1ID]
        global TXNID
        txn = f"{TXNID}: {self.peer1ID} pays {self.peer2ID} {self.amount} coins" # Each txn (except coinbase) is a string of this format
        
        if loggingTxn:
            fout.write(f"Time = {self.time} | GenTxn: {txn}\n") # Write event to log file
        peer1.txnpool[TXNID] = [0, txn] # Add txn to txnpool of peer and mark it as unused
        TXNID += 1 # increment TXNID as new txn is generated
        
        broadcastTxnToNeighbors(self.time, self.peer1ID, txn)
        
        sleepTime = rng.exponential(peerSleepBeta) # Next Txn will be generated by this peer after this much time
        
        # Randomly choose next peer and amount
        pids = list(range(len(nodeList)))
        pids.remove(self.peer1ID)
        peer2ID = nodeList[rng.choice(pids)].id
        # If we have a malicious peer, it will generate invalid txns and broadcast them
        
        if rng.random() < peer1.invalidTxnProb:
            amount = rng.integers(peer1.allBalances[self.peer1ID] + 10, peer1.allBalances[self.peer1ID] + 100)
        else:
            amount = rng.integers(0,peer1.allBalances[self.peer1ID]+1) if peer1.allBalances[self.peer1ID]>0 else 0
        
        recTime = self.time + sleepTime
        pq.put((recTime, next(unique), GenerateTransaction(recTime, self.peer1ID, peer2ID, amount)))
        
# Event for receiving a txn by a peer
class ReceiveTransaction():
    def __init__(self, time, peerID, txn):
        self.time = time
        self.peerID = peerID # receiver
        self.txn = txn

    def process(self):
        txnID = int(self.txn.split(":")[0]) # Extract txnID from txn
        # If txn is already in txnpool of a peer then we have seen this txn before so we can ignore it
        # This ensures loop-less forwarding of txn throughout the network
        if txnID not in nodeList[self.peerID].txnpool:
            if loggingTxn:
                fout.write(f"Time = {self.time} | RecTxn on Peer {self.peerID} | {self.txn}\n") # Write event in log file
            
            nodeList[self.peerID].txnpool[txnID] = [0, self.txn] # Add txn to txnpool and mark it as unused
            broadcastTxnToNeighbors(self.time, self.peerID, self.txn) # Broadcast Txn

# Event for starting mining by a peer
class GenerateBlock():
    def __init__(self, time, peerID, blk_parent):
        self.time = time
        self.peerID = peerID
        self.blk_parent = blk_parent
    
    def process(self):
        peer = nodeList[self.peerID]
        balances = peer.allBalances[:] # Create copy of balances so we don't change original values
        verifiedTxns = [] # The selected txns to be included in the block are stored in this list in order
        
        # malicious peer will try to include invalid txns in block
        # if peer.isMalicious:
        #     # Add 1 used txn in block
        #     addUsedTxn = True
        #     for txnID, val in peer.txnpool.items():
        #         if addUsedTxn and val[0] == 1:
        #             verifiedTxns.append(val[1])
        #             addUsedTxn = False
        #         elif val[0] == 0:
        #             verifiedTxns.append(val[1]) # Do not verify unused txn and just include it
        #         if len(verifiedTxns) >= 1024: # Do not include more than 1024 txns (max allowed size is 1MB)
        #             break
        # else:
        for txnID, val in peer.txnpool.items():
            if val[0] == 0: # If txn is used in longest chain, skip it. Otherwise try to include it
                txn = val[1]
                # tmp = txn.split()
                # sender, reciever, amount = int(tmp[1]), int(tmp[3]), int(tmp[4])
                # If txn violates this condition, skip it. Otherwise add it to the list
                # if sender >= 0 and sender < number_of_peers and reciever >=0 and reciever < number_of_peers and amount >=0 and balances[sender] >= amount:
                #     balances[sender] -= amount
                #     balances[reciever] += amount
                verifiedTxns.append(txn)
            if len(verifiedTxns) >= 1023: # Do not include more than 1024 txns (max allowed size is 1MB)
                break
        
        # T_k = rng.exponential(meanT_k[peer.id]) # Get mining time from exp. distribution
        # Block is generated here and it's ID is also fixed here. If longest chain changes during mining, this block 
        # will be discarded. So in the final blocktree we will se some block IDs missing
        broadcastTime = self.time
        miningBlock = Block(self.blk_parent, verifiedTxns, broadcastTime)

        # As ths block will be mined at self.time + T_k, we pass peerID and senderID the same value of self.peerID
        # to identify this as mining completed event
        pq.put((broadcastTime, next(unique), ReceiveBlock(broadcastTime, self.peerID, miningBlock, self.peerID)))

# Event for Receiving a block on a peer
class ReceiveBlock():
    # We also give the ID of the sender in this case to be able to identify mining case
    def __init__(self, time, peerID, block, senderID):
        self.time = time
        self.peerID = peerID
        self.block = block
        self.senderID = senderID
    
    def process(self):
        global TXNID
        peer = nodeList[self.peerID]
        if self.block.id in peer.blocktree: # If block already present in tree, discard it loopless forwarding
            return
        # if block already present in pending blocks, discard it
        elif self.block.parent in peer.pendingBlocks and self.block.id in [x[0] for x in peer.pendingBlocks[self.block.parent]]:
            return
        # If this condition is true, then self.peerID has possibly mined a block
        elif self.peerID == self.senderID:
            # if longest chain hasn't changed since starting the mining, meaning that the parent of the mined block is
            # the same as leaf of longest chain, then we have successfully mined a block. Otherwise we discard it
            # if self.block.parent == peer.longestChainLeaf:
            if loggingBlock:
                fout.write(f"Time = {self.time} | Block {self.block.id} Mined by Peer {self.peerID}\n") # Write event to log file
            
            coinbaseTxn = f"{TXNID}: {self.peerID} mines 50 coins" # generate coinbase txn for this block
            TXNID += 1 # increment TXNID as new txn is generated
            self.block.txns.append(coinbaseTxn) # add coinbase at the end of block txns
            
            # mark the txns present in this block as used
            for txn in self.block.txns[:-1]:
                peer.txnpool[int(txn.split(":")[0])] = (1, txn)
            
            peer.blocktree[self.block.id] = (self.block, self.time) # Add block to blocktree of peer
            peer.longestChainLeaf = self.block.id # update longest chain leaf
            # peer.longestChainLength += 1 # increment longest chain length
            peer.updateBalances(self.block.txns) # TODO: Recheck update balances of peers as new txns are included
            
            broadcastBlockToNeighbors(self.time, self.peerID, self.block)
            
            # Start Mining again
            # pq.put((self.time, next(unique), GenerateBlock(self.time, self.peerID)))
        
        else: 
            # If self.senderID is different from self.peerID, this means we have received a block from someone else


            # Try to add block in blocktree. Returns 0 if block is discarded, 1 if it is added in tree and 
            # -1 if it is a pending block
            def addBlock(block, arrivalTime):
                if block.id in peer.blocktree: # discard if block already in tree
                    return 0
                # discard if block already in pending blocks
                elif block.parent in peer.pendingBlocks and block.id in [x[0] for x in peer.pendingBlocks[block.parent]]:
                    return 0

                # In this case the block can possibly be attached to some block other than leaf.
                # Note parent is always accepted; Since somebody mined on it
                # Covers both cases: block.parent == peer.longestChainLeaf and block.parent != peer.longestChainLeaf
                elif block.parent in peer.blocktree:
                    
                    # Can also be rejected
                    assert(peer.blocktree[block.parent][0].accepted)
                    if peer.addBlock(block):
                        if loggingBlock:
                            fout.write(f"Time = {self.time} | Block {block.id} added by Peer {self.peerID} in Block Tree\n")
                        broadcastBlockToNeighbors(self.time, self.peerID, block) # broadcast block to neighbors
                        
                        # Voting by witnessNodes if block under vote
                        if peer.id in witnessNodes and block.id == BlkID:
                            block_Votes += 1
                        return 2 # leaf has changed
                    else:
                        return 0 # verify block failed
                
                # If block.parent is not in blocktree, we add it to pending blocks
                else:
                    if loggingBlock:
                        fout.write(f"Time = {self.time} | Block {block.id} added by Peer {self.peerID} in pending Blocks\n")
                    # If block.parent is a key in peer.pendingBlocks, we append it to the value otherwise we create and new
                    # key value pair in the dictionary
                    if block.parent in peer.pendingBlocks:
                        peer.pendingBlocks[block.parent].append((block, arrivalTime))
                    else:
                        peer.pendingBlocks[block.parent] = [(block, arrivalTime)]
                    return -1
            
            def removePendingChildren(blockID):
                if blockID in peer.pendingBlocks:
                    for pendingBlock, pendingTime in peer.pendingBlocks[blockID]:
                        removePendingChildren(pendingBlock.id)
                    peer.pendingBlocks.pop(blockID)
                    
            # To add pending blocks to block tree, we need to traverse self.pendingBlocks in a DFS manner, because when we 
            # receive a new block we need to check if any pending blocks has it as parent, then we try to add those blocks,
            # and if successful we try to add their children in pending blocks

            def addRecursive(block, arrivalTime):
                retval = addBlock(block, arrivalTime) # Try to add block in blocktree
                # If block is discarded, remove children of this block in pendingBlocks in a DFS manner
                if retval == 0:
                    if loggingBlock:
                        fout.write(f"Time = {self.time} | Block {block.id} discarded by Peer {self.peerID}\n")
                    removePendingChildren(block.id)
                elif retval == 1: # Proceed only if block is added in tree
                    # if the added block is parent to some blocks in pending blocks, we start DFS on those blocks
                    if block.id in peer.pendingBlocks: 
                        for pendingBlock, pendingTime in peer.pendingBlocks[block.id]:
                            addRecursive(pendingBlock, pendingTime)
                        # As these blocks have their parent in the tree, remove them from pending blocks
                        peer.pendingBlocks.pop(block.id)
            
            addRecursive(self.block, self.time) # add recursively from received block